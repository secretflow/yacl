diff --git a/examples/MODULE.bazel.lock b/examples/MODULE.bazel.lock
index 2f4b509..b9b80d4 100644
--- a/examples/MODULE.bazel.lock
+++ b/examples/MODULE.bazel.lock
@@ -1,5 +1,5 @@
 {
-  "lockFileVersion": 13,
+  "lockFileVersion": 11,
   "registryFileHashes": {
     "https://bcr.bazel.build/bazel_registry.json": "8a28e4aff06ee60aed2a8c281907fb8bcbf3b753c91fb5a5c57da3215d5b3497",
     "https://bcr.bazel.build/modules/abseil-cpp/20210324.2/MODULE.bazel": "7cd0312e064fde87c8d1cd79ba06c876bd23630c83466e9500321be55c96ace2",
diff --git a/examples/gc/BUILD.bazel b/examples/gc/BUILD.bazel
index 2ce288f..3bf1cd1 100644
--- a/examples/gc/BUILD.bazel
+++ b/examples/gc/BUILD.bazel
@@ -12,7 +12,7 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
-load("@yacl//bazel:yacl.bzl", "yacl_cc_binary", "yacl_cc_library", "yacl_cc_test")
+load("@yacl//bazel:yacl.bzl", "yacl_cc_library", "yacl_cc_test")
 
 package(default_visibility = ["//visibility:public"])
 
@@ -21,23 +21,19 @@ yacl_cc_library(
     hdrs = [
         "mitccrh.h",
     ],
-    copts = [
-        "-mavx",
-        "-maes",
-        "-mpclmul",
-    ],
     deps = [
         ":utils",
-        "//yacl/base:int128",
         "//yacl/crypto/aes:aes_opt",
-        "//yacl/crypto/tools:crhash",
     ],
 )
 
 yacl_cc_library(
     name = "utils",
     hdrs = ["utils.h"],
-    deps = ["//yacl/math/mpint:mpint",],
+    deps = [
+        "//yacl/base:byte_container_view",
+        "//yacl/base:int128",
+    ],
 )
 
 yacl_cc_library(
@@ -45,22 +41,11 @@ yacl_cc_library(
     hdrs = [
         "aes_128_garbler.h",
     ],
-    copts = [
-        "-mavx",
-        "-maes",
-        "-mpclmul",
-    ],
     deps = [
         ":mitccrh",
         "//yacl/base:byte_container_view",
-        "//yacl/base:dynamic_bitset",
-        "//yacl/base:int128",
-        "//yacl/crypto/rand",
         "//yacl/io/circuit:bristol_fashion",
-        "//yacl/kernel/algorithms:base_ot",
-        "//yacl/kernel/algorithms:iknp_ote",
         "//yacl/kernel:ot_kernel",
-        "//yacl/kernel/type:ot_store_utils",
     ],
 )
 
@@ -69,18 +54,9 @@ yacl_cc_library(
     hdrs = [
         "sha256_garbler.h",
     ],
-    copts = [
-        "-mavx",
-        "-maes",
-        "-mpclmul",
-    ],
     deps = [
         ":mitccrh",
-        "//yacl/base:int128",
-        "//yacl/crypto/block_cipher:symmetric_crypto",
         "//yacl/base:byte_container_view",
-        "//yacl/base:dynamic_bitset",
-        "//yacl/crypto/rand",
         "//yacl/io/circuit:bristol_fashion",
     ],
 )
@@ -90,17 +66,9 @@ yacl_cc_library(
     hdrs = [
         "sha256_evaluator.h",
     ],
-    copts = [
-        "-mavx",
-        "-maes",
-        "-mpclmul",
-    ],
     deps = [
         ":mitccrh",
-        "//yacl/base:int128",
         "//yacl/base:byte_container_view",
-        "//yacl/base:dynamic_bitset",
-        "//yacl/crypto/rand",
         "//yacl/io/circuit:bristol_fashion",
     ],
 )
@@ -110,22 +78,11 @@ yacl_cc_library(
     hdrs = [
         "aes_128_evaluator.h",
     ],
-    copts = [
-        "-mavx",
-        "-maes",
-        "-mpclmul",
-    ],
     deps = [
         ":mitccrh",
-        "//yacl/base:int128",
         "//yacl/base:byte_container_view",
-        "//yacl/base:dynamic_bitset",
-        "//yacl/crypto/rand",
         "//yacl/io/circuit:bristol_fashion",
-        "//yacl/kernel/algorithms:base_ot",
-        "//yacl/kernel/algorithms:iknp_ote",
         "//yacl/kernel:ot_kernel",
-        "//yacl/kernel/type:ot_store_utils",
     ],
 )
 
@@ -139,10 +96,9 @@ yacl_cc_test(
     ],
     data = ["//yacl/io/circuit:circuit_data"],
     deps = [
-        ":sha256_garbler",
-        ":sha256_evaluator",
         ":aes_128_evaluator",
         ":aes_128_garbler",
-        "//yacl/crypto/block_cipher:symmetric_crypto",
+        ":sha256_evaluator",
+        ":sha256_garbler",
     ],
-)
\ No newline at end of file
+)
diff --git a/examples/gc/aes_128_evaluator.h b/examples/gc/aes_128_evaluator.h
index 156a6dc..3b9c968 100644
--- a/examples/gc/aes_128_evaluator.h
+++ b/examples/gc/aes_128_evaluator.h
@@ -17,21 +17,21 @@
 
 #include "examples/gc/mitccrh.h"
 #include "fmt/format.h"
+#include "spdlog/spdlog.h"
 
 #include "yacl/base/byte_container_view.h"
 #include "yacl/base/dynamic_bitset.h"
 #include "yacl/base/int128.h"
 #include "yacl/crypto/rand/rand.h"
 #include "yacl/io/circuit/bristol_fashion.h"
-#include "yacl/kernel/algorithms/base_ot.h"
-#include "yacl/kernel/algorithms/iknp_ote.h"
 #include "yacl/kernel/ot_kernel.h"
-#include "yacl/kernel/type/ot_store_utils.h"
 #include "yacl/link/context.h"
 #include "yacl/link/factory.h"
+
 using namespace std;
 using namespace yacl;
 using namespace yacl::crypto;
+
 namespace {
 
 using OtMsg = uint128_t;
@@ -55,7 +55,7 @@ class EvaluatorAES {
   uint128_t table[36663][2];
   uint128_t input;
   int num_ot = 128;
-  uint128_t all_one_uint128_t = ~static_cast<__uint128_t>(0);
+  uint128_t all_one_uint128_t = ~static_cast<uint128_t>(0);
   uint128_t select_mask[2] = {0, all_one_uint128_t};
 
   yacl::crypto::OtRecvStore ot_recv =
@@ -87,7 +87,7 @@ class EvaluatorAES {
     yacl::Buffer r = lctx->Recv(0, "tmp");
     const uint128_t* buffer_data = r.data<const uint128_t>();
     memcpy(tmp, buffer_data, sizeof(uint128_t) * 3);
-    std::cout << "tmpRecv" << std::endl;
+    SPDLOG_INFO("tmpRecv");
 
     delta = tmp[0];
     inv_constant = tmp[1];
@@ -104,7 +104,7 @@ class EvaluatorAES {
     yacl::dynamic_bitset<uint128_t> bi_val;
 
     input = yacl::crypto::FastRandU128();
-    std::cout << "input of evaluator:" << input << std::endl;
+    SPDLOG_INFO("input of evaluator: {}", input);
     bi_val.append(input);
 
     yacl::Buffer r = lctx->Recv(0, "garbleInput1");
@@ -113,7 +113,7 @@ class EvaluatorAES {
 
     memcpy(wires_.data(), buffer_data, sizeof(uint128_t) * num_ot);
 
-    std::cout << "recvInput1" << std::endl;
+    SPDLOG_INFO("recvInput1");
 
     lctx->Send(0, yacl::ByteContainerView(&input, sizeof(uint128_t)), "Input1");
 
@@ -130,7 +130,7 @@ class EvaluatorAES {
       }
     }
 
-    std::cout << "recvTable" << std::endl;
+    SPDLOG_INFO("recvTable");
   }
 
   uint128_t EVAND(uint128_t A, uint128_t B, const uint128_t* table_item,
@@ -201,7 +201,7 @@ class EvaluatorAES {
                yacl::ByteContainerView(wires_.data() + start,
                                        sizeof(uint128_t) * num_ot),
                "output");
-    std::cout << "sendOutput" << std::endl;
+    SPDLOG_INFO("sendOutput");
   }
   void onLineOT() {
     yacl::dynamic_bitset<uint128_t> choices;
diff --git a/examples/gc/aes_128_garbler.h b/examples/gc/aes_128_garbler.h
index 67efd3e..5e04792 100644
--- a/examples/gc/aes_128_garbler.h
+++ b/examples/gc/aes_128_garbler.h
@@ -19,16 +19,14 @@
 #include "absl/types/span.h"
 #include "examples/gc/mitccrh.h"
 #include "fmt/format.h"
+#include "spdlog/spdlog.h"
 
 #include "yacl/base/byte_container_view.h"
 #include "yacl/base/dynamic_bitset.h"
 #include "yacl/base/int128.h"
 #include "yacl/crypto/rand/rand.h"
 #include "yacl/io/circuit/bristol_fashion.h"
-#include "yacl/kernel/algorithms/base_ot.h"
-#include "yacl/kernel/algorithms/iknp_ote.h"
 #include "yacl/kernel/ot_kernel.h"
-#include "yacl/kernel/type/ot_store_utils.h"
 #include "yacl/link/context.h"
 #include "yacl/link/factory.h"
 
@@ -41,16 +39,6 @@ inline uint128_t Aes128(uint128_t k, uint128_t m) {
   return enc.Encrypt(m);
 }
 
-uint128_t ReverseBytes(uint128_t x) {
-  auto byte_view = ByteContainerView(&x, sizeof(x));
-  uint128_t ret = 0;
-  auto buf = std::vector<uint8_t>(sizeof(ret));
-  for (size_t i = 0; i < byte_view.size(); ++i) {
-    buf[byte_view.size() - i - 1] = byte_view[i];
-  }
-  std::memcpy(&ret, buf.data(), buf.size());
-  return ret;
-}
 class GarblerAES {
  public:
   std::shared_ptr<yacl::link::Context> lctx;
@@ -109,7 +97,7 @@ class GarblerAES {
     }
     tmp[0] = tmp[0] | 1;
     lctx->Send(1, yacl::ByteContainerView(tmp, sizeof(uint128_t) * 3), "tmp");
-    std::cout << "tmpSend" << std::endl;
+    SPDLOG_INFO("tmpSend");
 
     delta = tmp[0];
     inv_constant = tmp[1] ^ delta;
@@ -124,7 +112,7 @@ class GarblerAES {
     wires_.resize(circ_.nw);
 
     input = yacl::crypto::FastRandU128();
-    std::cout << "input of garbler:" << input << std::endl;
+    SPDLOG_INFO("input of garbler: {}", input);
 
     yacl::dynamic_bitset<uint128_t> bi_val;
     bi_val.append(input);
@@ -153,7 +141,7 @@ class GarblerAES {
         1, yacl::ByteContainerView(wires_.data(), sizeof(uint128_t) * num_ot),
         "garbleInput1");
 
-    std::cout << "sendInput1" << std::endl;
+    SPDLOG_INFO("sendInput1");
 
     // onlineOT();
 
@@ -244,7 +232,7 @@ class GarblerAES {
     lctx->Send(1,
                yacl::ByteContainerView(table, sizeof(uint128_t) * 2 * circ_.ng),
                "table");
-    std::cout << "sendTable" << std::endl;
+    SPDLOG_INFO("sendTable");
   }
   uint128_t decode() {
     size_t index = wires_.size();
@@ -254,15 +242,14 @@ class GarblerAES {
     const uint128_t* buffer_data = r.data<const uint128_t>();
 
     memcpy(wires_.data() + start, buffer_data, sizeof(uint128_t) * num_ot);
-    std::cout << "recvOutput" << std::endl;
+    SPDLOG_INFO("recvOutput");
 
     // decode
     std::vector<uint128_t> result(1);
     finalize(absl::MakeSpan(result));
-    std::cout << "MPC结果：" << ReverseBytes(result[0]) << std::endl;
-    std::cout << "明文结果："
-              << Aes128(ReverseBytes(input), ReverseBytes(input_EV))
-              << std::endl;
+    SPDLOG_INFO("MPC结果：{}", ReverseBytes(result[0]));
+    SPDLOG_INFO("明文结果：{}",
+                Aes128(ReverseBytes(input), ReverseBytes(input_EV)));
     return result[0];
   }
 
diff --git a/examples/gc/gc_test.cc b/examples/gc/gc_test.cc
index ea8a115..2e2b307 100644
--- a/examples/gc/gc_test.cc
+++ b/examples/gc/gc_test.cc
@@ -12,6 +12,8 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
+#include <filesystem>
+#include <future>
 #include <vector>
 
 #include "examples/gc/aes_128_evaluator.h"
@@ -31,17 +33,6 @@ inline uint128_t Aes128(uint128_t k, uint128_t m) {
   return enc.Encrypt(m);
 }
 
-uint128_t ReverseBytes(uint128_t x) {
-  auto byte_view = ByteContainerView(&x, sizeof(x));
-  uint128_t ret = 0;
-  auto buf = std::vector<uint8_t>(sizeof(ret));
-  for (size_t i = 0; i < byte_view.size(); ++i) {
-    buf[byte_view.size() - i - 1] = byte_view[i];
-  }
-  std::memcpy(&ret, buf.data(), buf.size());
-  return ret;
-}
-
 TEST(GCTest, SHA256Test) {
   std::shared_ptr<yacl::io::BFCircuit> circ_;
 
diff --git a/examples/gc/mitccrh.h b/examples/gc/mitccrh.h
index 6432782..28f591a 100644
--- a/examples/gc/mitccrh.h
+++ b/examples/gc/mitccrh.h
@@ -14,13 +14,10 @@
 
 #pragma once
 
-#include <stdio.h>
-
 #include "utils.h"
 
-#include "yacl/base/int128.h"
 #include "yacl/crypto/aes/aes_opt.h"
-#include "yacl/crypto/tools/crhash.h"
+
 /*
  * [REF] Implementation of "Better Concrete Security for Half-Gates Garbling (in
  * the Multi-Instance Setting)" https://eprint.iacr.org/2019/1168.pdf
diff --git a/examples/gc/sha256_evaluator.h b/examples/gc/sha256_evaluator.h
index 38b4089..84912c5 100644
--- a/examples/gc/sha256_evaluator.h
+++ b/examples/gc/sha256_evaluator.h
@@ -18,15 +18,14 @@
 
 #include "examples/gc/mitccrh.h"
 #include "fmt/format.h"
+#include "spdlog/spdlog.h"
 
 #include "yacl/base/byte_container_view.h"
-#include "yacl/base/dynamic_bitset.h"
 #include "yacl/base/int128.h"
-#include "yacl/crypto/rand/rand.h"
 #include "yacl/io/circuit/bristol_fashion.h"
 #include "yacl/link/context.h"
 #include "yacl/link/factory.h"
-#include "yacl/link/test_util.h"
+
 using namespace std;
 using namespace yacl;
 using namespace yacl::crypto;
@@ -67,7 +66,7 @@ class EvaluatorSHA256 {
     yacl::Buffer r = lctx->Recv(0, "tmp");
     const uint128_t* buffer_data = r.data<const uint128_t>();
     memcpy(tmp, buffer_data, sizeof(uint128_t) * 3);
-    std::cout << "tmpRecv" << std::endl;
+    SPDLOG_INFO("tmpRecv");
 
     delta = tmp[0];
     inv_constant = tmp[1];
@@ -87,7 +86,7 @@ class EvaluatorSHA256 {
 
     memcpy(wires_.data(), buffer_data, sizeof(uint128_t) * num_ot);
 
-    std::cout << "recvInput1" << std::endl;
+    SPDLOG_INFO("recvInput1");
   }
   void recvTable() {
     yacl::Buffer r = lctx->Recv(0, "table");
@@ -100,7 +99,7 @@ class EvaluatorSHA256 {
       }
     }
 
-    std::cout << "recvTable" << std::endl;
+    SPDLOG_INFO("recvTable");
   }
 
   uint128_t EVAND(uint128_t A, uint128_t B, const uint128_t* table_item,
@@ -171,6 +170,6 @@ class EvaluatorSHA256 {
         0,
         yacl::ByteContainerView(wires_.data() + start, sizeof(uint128_t) * 256),
         "output");
-    std::cout << "sendOutput" << std::endl;
+    SPDLOG_INFO("sendOutput");
   }
 };
\ No newline at end of file
diff --git a/examples/gc/sha256_garbler.h b/examples/gc/sha256_garbler.h
index 944fe2e..c141603 100644
--- a/examples/gc/sha256_garbler.h
+++ b/examples/gc/sha256_garbler.h
@@ -19,11 +19,11 @@
 #include "absl/types/span.h"
 #include "examples/gc/mitccrh.h"
 #include "fmt/format.h"
+#include "spdlog/spdlog.h"
 
 #include "yacl/base/byte_container_view.h"
 #include "yacl/base/dynamic_bitset.h"
 #include "yacl/base/int128.h"
-#include "yacl/crypto/block_cipher/symmetric_crypto.h"
 #include "yacl/crypto/hash/ssl_hash.h"
 #include "yacl/crypto/rand/rand.h"
 #include "yacl/io/circuit/bristol_fashion.h"
@@ -86,7 +86,7 @@ class GarblerSHA256 {
     }
     tmp[0] = tmp[0] | 1;
     lctx->Send(1, yacl::ByteContainerView(tmp, sizeof(uint128_t) * 3), "tmp");
-    std::cout << "tmpSend" << std::endl;
+    SPDLOG_INFO("tmpSend");
 
     delta = tmp[0];
     inv_constant = tmp[1] ^ delta;
@@ -103,10 +103,11 @@ class GarblerSHA256 {
     message = crypto::FastRandBytes(crypto::RandLtN(32));
     auto in_buf = io::BuiltinBFCircuit::PrepareSha256Input(message);
     auto sha256_result = crypto::Sha256Hash().Update(message).CumulativeHash();
+
+    SPDLOG_DEBUG("inputProcess");
     for (int i = 0; i < 32; i++) {
-      cout << int(sha256_result[i]) << " ";
+      SPDLOG_DEBUG("{}", int(sha256_result[i]));
     }
-    cout << endl;
 
     dynamic_bitset<uint8_t> bi_val;
     bi_val.resize(circ_.nw);
@@ -136,7 +137,7 @@ class GarblerSHA256 {
         1, yacl::ByteContainerView(wires_.data(), sizeof(uint128_t) * num_ot),
         "garbleInput1");
 
-    std::cout << "sendInput1" << std::endl;
+    SPDLOG_INFO("sendInput1");
 
     return sha256_result;
   }
@@ -220,8 +221,9 @@ class GarblerSHA256 {
     lctx->Send(1,
                yacl::ByteContainerView(table, sizeof(uint128_t) * 2 * circ_.ng),
                "table");
-    std::cout << "sendTable" << std::endl;
+    SPDLOG_INFO("sendTable");
   }
+
   vector<uint8_t> decode() {
     size_t index = wires_.size();
     int start = index - circ_.now[0];
@@ -229,7 +231,7 @@ class GarblerSHA256 {
     yacl::Buffer r = lctx->Recv(1, "output");
 
     memcpy(wires_.data() + start, r.data(), sizeof(uint128_t) * 256);
-    std::cout << "recvOutput" << std::endl;
+    SPDLOG_INFO("recvOutput");
 
     const auto out_size = 32;
     std::vector<uint8_t> out(out_size);
@@ -247,9 +249,8 @@ class GarblerSHA256 {
 
     auto sha256_result = crypto::Sha256Hash().Update(message).CumulativeHash();
 
-    if (sha256_result.size() == out.size() &&
-        std::equal(out.begin(), out.end(), sha256_result.begin()))
-      cout << "YES!!!" << endl;
+    YACL_ENFORCE(sha256_result.size() == out.size() &&
+                 std::equal(out.begin(), out.end(), sha256_result.begin()));
 
     return out;
   }
diff --git a/examples/gc/utils.h b/examples/gc/utils.h
index ca084c7..b3ba005 100644
--- a/examples/gc/utils.h
+++ b/examples/gc/utils.h
@@ -12,19 +12,19 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-#include <bits/stdc++.h>
-#include <emmintrin.h>
-#include <openssl/sha.h>
-
-#include <cstdint>
-#include <cstring>
-#include <iostream>
-#include <memory>
-#include <random>
-
-#include "yacl/math/mpint/mp_int.h"
-
-using uint128_t = __uint128_t;
+#include "yacl/base/byte_container_view.h"
+#include "yacl/base/int128.h"
 
 // get the Least Significant Bit of uint128_t
 inline bool getLSB(const uint128_t& x) { return (x & 1) == 1; }
+
+uint128_t ReverseBytes(uint128_t x) {
+  auto byte_view = yacl::ByteContainerView(&x, sizeof(x));
+  uint128_t ret = 0;
+  auto buf = std::vector<uint8_t>(sizeof(ret));
+  for (size_t i = 0; i < byte_view.size(); ++i) {
+    buf[byte_view.size() - i - 1] = byte_view[i];
+  }
+  std::memcpy(&ret, buf.data(), buf.size());
+  return ret;
+}
\ No newline at end of file
