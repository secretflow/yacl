// Copyright 2019 Ant Group Co., Ltd.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#pragma once

#include <array>
#include <cstring>
#include <memory>
#include <numeric>
#include <vector>

#include "yacl/base/dynamic_bitset.h"
#include "yacl/base/int128.h"
#include "yacl/crypto/base/drbg/drbg.h"
#include "yacl/crypto/base/drbg/entropy_source.h"
#include "yacl/crypto/base/drbg/nist_aes_drbg.h"
#include "yacl/crypto/base/drbg/sm4_drbg.h"
#include "yacl/crypto/base/symmetric_crypto.h"

namespace yacl::crypto {

namespace internal {
template <typename T, size_t BATCH_SIZE>
struct cipher_data {
  std::array<T, BATCH_SIZE> cipher_budget_{};

  size_t size() { return BATCH_SIZE * sizeof(T); }
  T& operator[](size_t idx) { return cipher_budget_[idx]; }
  const T& operator[](size_t idx) const { return cipher_budget_[idx]; }
};

template <size_t BATCH_SIZE>
struct cipher_data<bool, BATCH_SIZE> {
  dynamic_bitset<uint128_t> cipher_budget_;

  cipher_data() { cipher_budget_ = dynamic_bitset<uint128_t>(BATCH_SIZE * 8); }
  size_t size() { return BATCH_SIZE; }

  bool operator[](const size_t& idx) { return cipher_budget_[idx]; }
  bool operator[](const size_t& idx) const { return cipher_budget_[idx]; }
};
}  // namespace internal

///////////////////////////////////////////////////////////////////
//                  Fill Pseudorandom (PRand)                    //
///////////////////////////////////////////////////////////////////

// FillPRandBytes generate pseudo random bytes and fill the `out`.
uint64_t FillPRandBytes(SymmetricCrypto::CryptoType crypto_type, uint128_t seed,
                        uint128_t iv, uint64_t count, absl::Span<uint8_t> out);

// Fill pseudo-randomness with type-T
template <typename T,
          std::enable_if_t<std::is_standard_layout<T>::value, int> = 0>
inline uint64_t FillPRand(SymmetricCrypto::CryptoType crypto_type,
                          uint128_t seed, uint128_t iv, uint64_t count,
                          absl::Span<T> out) {
  const size_t nbytes = out.size() * sizeof(T);
  std::vector<uint8_t> tmp(nbytes);
  auto ctr = FillPRandBytes(crypto_type, seed, iv, count, absl::MakeSpan(tmp));
  std::memcpy(out.data(), tmp.data(), nbytes);
  return ctr;
}

// The pseudo random bytes are generated by using AES-CBC to encrypt a
// continuous buffer with incremental counters as contents.

#define DECLARE_FILLPRand_TYPE(TYPE)                                       \
  template <typename T,                                                    \
            std::enable_if_t<std::is_standard_layout<T>::value, int> = 0>  \
  inline uint64_t FillPRand_##TYPE(uint128_t seed, uint64_t count,         \
                                   absl::Span<T> out) {                    \
    return FillPRand<T>(SymmetricCrypto::CryptoType::TYPE, seed, 0, count, \
                        out);                                              \
  }

DECLARE_FILLPRand_TYPE(SM4_CBC);     // declare FillPRand_SM4_CBC
DECLARE_FILLPRand_TYPE(AES128_CBC);  // declare FillPRand_AES128_CBC

///////////////////////////////////////////////////////////////////
//                              PRG                              //
///////////////////////////////////////////////////////////////////

// This is an implementation of the **theoretical tool**: Pseudorandom
// Generator

enum class PRG_MODE {
  // nist drbg standard
  // get random seed from intel entropy source, generate pseudorandom bytes
  kNistAesCtrDrbg,
  // gm drbg
  // get random seed from intel entropy source, generate pseudorandom bytes
  kGmSm4CtrDrbg,
  // aes ecb (with an internal counter)
  // get seed from parameter, use ctr mode, generate pseudorandom bytes
  kAesEcb,  // use aes128
  // sm4 ecb (with an internal counter)
  // get seed from parameter, use ctr mode, generate pseudorandom bytes
  KSm4Ecb
};

template <typename T, size_t BATCH_SIZE = 16,
          std::enable_if_t<std::is_standard_layout_v<T>, int> = 0>
class Prg {
 public:
  static_assert(BATCH_SIZE * sizeof(T) % sizeof(uint128_t) == 0);

  // constructor
  explicit Prg(uint128_t seed = 0, PRG_MODE mode = PRG_MODE::kAesEcb)
      : mode_(mode) {
    SetSeed(seed);
    if (mode_ == PRG_MODE::kNistAesCtrDrbg) {
      ctr_drbg_ = std::make_unique<NistAesDrbg>(seed);
    } else if (mode_ == PRG_MODE::kGmSm4CtrDrbg) {
      ctr_drbg_ = std::make_unique<Sm4Drbg>(seed);
    }
  }

  uint128_t Seed() const { return seed_; }
  uint128_t Counter() const { return counter_; }

  static constexpr size_t BatchSize() { return BATCH_SIZE; }

  void SetSeed(uint128_t seed) {
    seed_ = seed;
    counter_ = 0;  // Reset counter. Make this behave same with STL PRG.
  }

  void SetStatus(uint128_t seed, uint128_t counter) {
    seed_ = seed;
    counter_ = counter;
  }

  T operator()() {
    if (num_consumed_ == cipher_data_.cipher_budget_.size()) {
      GenerateBudgets();  // Generate budgets.
      num_consumed_ = 0;  // Reset consumed.
    }
    return cipher_data_[num_consumed_++];
  }

  // `Fill` does not consumes cipher_budgets but do increase the internal
  // counter.
  template <typename Y,
            std::enable_if_t<std::is_trivially_copyable_v<Y>, int> = 0>
  void Fill(absl::Span<Y> out) {
    switch (mode_) {
      case PRG_MODE::kNistAesCtrDrbg:
      case PRG_MODE::kGmSm4CtrDrbg:
        ctr_drbg_->FillPRand<Y>(out);
        break;
      case PRG_MODE::kAesEcb:
        counter_ = FillPRand<Y>(SymmetricCrypto::CryptoType::AES128_ECB, seed_,
                                kInitVector, counter_, out);
        break;
      case PRG_MODE::KSm4Ecb:
        counter_ = FillPRand<Y>(SymmetricCrypto::CryptoType::SM4_ECB, seed_,
                                kInitVector, counter_, out);
        break;
    }
  }

  inline static constexpr uint128_t kInitVector = 0;

 private:
  void GenerateBudgets() {
    auto* cipher_ptr =
        reinterpret_cast<uint8_t*>(cipher_data_.cipher_budget_.data());
    size_t cipher_size = cipher_data_.size();

    switch (mode_) {
      case PRG_MODE::kNistAesCtrDrbg:
      case PRG_MODE::kGmSm4CtrDrbg:
        ctr_drbg_->FillPRandBytes(absl::MakeSpan(cipher_ptr, cipher_size));
        break;
      case PRG_MODE::kAesEcb:
        counter_ = FillPRandBytes(SymmetricCrypto::CryptoType::AES128_ECB,
                                  seed_, kInitVector, counter_,
                                  absl::MakeSpan(cipher_ptr, cipher_size));
        break;
      case PRG_MODE::KSm4Ecb:
        counter_ = FillPRandBytes(SymmetricCrypto::CryptoType::SM4_ECB, seed_,
                                  kInitVector, counter_,
                                  absl::MakeSpan(cipher_ptr, cipher_size));
        break;
    }
  }

  uint128_t seed_;                                    // Seed.
  uint128_t counter_ = 0;                             // Counter.
  internal::cipher_data<T, BATCH_SIZE> cipher_data_;  // budget (in bytes).
  size_t num_consumed_ = BATCH_SIZE;  // How many ciphers are consumed.

  PRG_MODE mode_;                    // prg mode
  std::unique_ptr<IDrbg> ctr_drbg_;  // for nist aes ctr drbg
};

///////////////////////////////////////////////////////////////////
//                              PRG                              //
///////////////////////////////////////////////////////////////////
// Since Prg is over-complex for simple tasks, here we provide a simple, yet
// useful way of using Prg.
template <typename T,
          std::enable_if_t<std::is_standard_layout<T>::value, int> = 0>
inline void PrgAesCtr(const uint128_t seed, absl::Span<T> out) {
  FillPRand<T>(SymmetricCrypto::CryptoType::AES128_CTR, seed, 0, 0, out);
}

template <typename T,
          std::enable_if_t<std::is_standard_layout<T>::value, int> = 0>
inline std::vector<T> PrgAesCtr(const uint128_t seed, const size_t num) {
  std::vector<T> res(num);
  FillPRand<T>(SymmetricCrypto::CryptoType::AES128_CTR, seed, 0, 0,
               absl::MakeSpan(res));
  return res;
}

template <typename T,
          std::enable_if_t<std::is_standard_layout<T>::value, int> = 0>
inline std::vector<T> PrgAesCbc(const uint128_t seed, const size_t num) {
  std::vector<T> res(num);
  FillPRand<T>(SymmetricCrypto::CryptoType::AES128_CBC, seed, 0, 0,
               absl::MakeSpan(res));
  return res;
}

}  // namespace yacl::crypto
